# Deployment: Manages a set of identical Pods and ensures desired state
#
# A Deployment is like a manager that ensures your application is always running
# with the correct number of copies (replicas). If a pod crashes, the Deployment
# automatically creates a new one. It also handles rolling updates when you
# deploy new versions.
#
# Key concepts:
# - Declarative: You declare "I want 3 replicas" and Kubernetes makes it happen
# - Self-healing: Crashed pods are automatically recreated
# - Rolling updates: Deploy new versions with zero downtime
# - Rollback: Easy to revert to previous versions
#
# Learn more: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/

apiVersion: apps/v1         # API version - 'apps/v1' is for workload resources
kind: Deployment            # Resource type - manages pods
metadata:
  name: go-app              # Deployment name - used to identify this deployment
  namespace: go-demo        # Which namespace this belongs to (created in namespace.yaml)
  labels:                   # Labels help organize and select resources
    app: go-app             # App identifier - critical for service discovery
    version: v1             # Version label - useful for canary deployments
spec:
  # ===================
  # REPLICA MANAGEMENT
  # ===================
  # This controls how many copies (pods) of your app should run
  replicas: 3               # Run 3 identical copies for high availability and load balancing
                           # Kubernetes will maintain exactly 3 pods at all times

  # ===================
  # POD SELECTOR
  # ===================
  # How the Deployment finds which pods it manages
  # This MUST match the labels in the pod template below
  selector:
    matchLabels:
      app: go-app           # Manages all pods with label 'app=go-app'

  # ===================
  # UPDATE STRATEGY
  # ===================
  # How to handle updates when you deploy a new version
  strategy:
    type: RollingUpdate     # Update pods gradually (alternative: Recreate - kills all then creates new)
    rollingUpdate:
      maxSurge: 1           # Create 1 extra pod above desired count during update (3 â†’ 4 temporarily)
      maxUnavailable: 1     # Allow 1 pod to be unavailable during update (always have 2+ running)
                           # This ensures zero downtime during deployments

  # ===================
  # POD TEMPLATE
  # ===================
  # Template for creating pods - this is the spec for each replica
  template:
    metadata:
      labels:               # These labels MUST match the selector above
        app: go-app
        version: v1
    spec:
      # Pod-level security settings
      # Running as non-root improves security (principle of least privilege)
      securityContext:
        runAsNonRoot: true  # Refuse to run containers as root user
        runAsUser: 1000     # UID to run containers (matches our Dockerfile)
        fsGroup: 1000       # GID for filesystem access

      # ===================
      # CONTAINERS
      # ===================
      # A pod can have multiple containers, but usually has one main container
      containers:
      - name: go-app        # Container name (for logging and debugging)
        # Image from our local registry (localhost:5001)
        # Format: registry/image:tag
        image: localhost:5001/go-app:latest
        imagePullPolicy: Always  # Always pull the image (useful for :latest tag)
                                # Options: Always, IfNotPresent, Never

        # ===================
        # NETWORKING
        # ===================
        # Expose ports from the container
        ports:
        - name: http        # Named port (services can reference by name)
          containerPort: 8080  # Port the container listens on (matches our Go app)
          protocol: TCP     # Protocol (TCP or UDP)

        # ===================
        # CONFIGURATION
        # ===================
        # Environment variables injected into the container
        # These are available to your application code
        env:
        - name: PORT
          value: "8080"     # Tell our Go app which port to use
        - name: APP_NAME
          value: "go-demo-app"
        - name: APP_VERSION
          value: "1.0.0"
        # Advanced: Can also load from ConfigMaps or Secrets
        # Example:
        # - name: DB_PASSWORD
        #   valueFrom:
        #     secretKeyRef:
        #       name: db-secret
        #       key: password

        # ===================
        # RESOURCE MANAGEMENT
        # ===================
        # CPU and memory allocation for this container
        # Kubernetes uses these to schedule pods on nodes
        resources:
          requests:         # Guaranteed resources (reserved for this container)
            memory: "32Mi"  # 32 Mebibytes of RAM
            cpu: "50m"      # 50 millicores (0.05 CPU cores)
                           # Scheduler ensures node has this much available
          limits:           # Maximum resources (hard limit - container killed if exceeded)
            memory: "64Mi"  # OOM killed if exceeds 64Mi
            cpu: "100m"     # Throttled if exceeds 100 millicores
        # Why both? Requests ensure availability, limits prevent resource hogging
        # Learn more: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

        # ===================
        # HEALTH CHECKS
        # ===================
        # Liveness Probe: "Is the container alive?"
        # If this fails, Kubernetes will RESTART the container
        # Use this to detect deadlocks or hung processes
        livenessProbe:
          httpGet:
            path: /health   # HTTP GET to this endpoint
            port: http      # Use the named port defined above
          initialDelaySeconds: 10  # Wait 10s after container starts before first check
          periodSeconds: 10        # Check every 10 seconds
          timeoutSeconds: 3        # Wait max 3s for response
          successThreshold: 1      # 1 success = healthy
          failureThreshold: 3      # 3 failures = restart container
        # Learn more: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/

        # Readiness Probe: "Is the container ready to serve traffic?"
        # If this fails, Kubernetes REMOVES the pod from service endpoints
        # Traffic won't be sent to this pod until it's ready
        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 5   # Start checking after 5s (faster than liveness)
          periodSeconds: 5         # Check every 5 seconds
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 3
        # Use case: During startup, app loads data, connects to DB, etc.
        # Pod isn't ready until these complete. This prevents serving errors.

        # ===================
        # CONTAINER SECURITY
        # ===================
        # Container-level security settings (more specific than pod-level)
        securityContext:
          allowPrivilegeEscalation: false  # Prevent gaining more privileges
          readOnlyRootFilesystem: false    # Allow writing (true is more secure but requires volume mounts)
          runAsNonRoot: true               # Double-check we're not running as root
          runAsUser: 1000                  # Explicit UID
          capabilities:                    # Linux capabilities
            drop:
            - ALL                          # Drop all capabilities (least privilege)
                                          # Our app doesn't need special permissions

      # ===================
      # POD POLICIES
      # ===================
      restartPolicy: Always                # Always restart containers if they exit
                                          # Options: Always, OnFailure, Never

      dnsPolicy: ClusterFirst              # Use cluster DNS first, then node's DNS
                                          # Enables service discovery by name

      terminationGracePeriodSeconds: 30    # Time to gracefully shutdown before SIGKILL
                                          # App should handle SIGTERM and clean up
