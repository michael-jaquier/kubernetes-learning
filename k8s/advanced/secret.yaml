# Secret Example
#
# Secrets store sensitive data like passwords, tokens, and keys.
# They're similar to ConfigMaps but designed for confidential information.
#
# Important: Secrets are base64 encoded, NOT encrypted by default!
# For production, use encryption at rest or external secret managers.
#
# Use cases:
# - Database passwords
# - API keys and tokens
# - TLS certificates
# - SSH keys
#
# Learn more: https://kubernetes.io/docs/concepts/configuration/secret/

apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: go-demo
  labels:
    app: go-app
type: Opaque  # Generic secret type (others: kubernetes.io/tls, kubernetes.io/dockerconfigjson)
data:
  # Values MUST be base64 encoded
  # To encode: echo -n "mypassword" | base64
  # To decode: echo "bXlwYXNzd29yZA==" | base64 -d

  DB_PASSWORD: bXlzZWNyZXRwYXNzd29yZA==     # "mysecretpassword"
  API_KEY: YWJjZGVmZ2hpamtsbW5vcA==         # "abcdefghijklmnop"
  JWT_SECRET: c3VwZXJzZWNyZXRrZXkxMjM=       # "supersecretkey123"

# Alternative: stringData (automatically base64 encoded)
stringData:
  # Use this for easier creation - Kubernetes encodes it for you
  ADMIN_USER: "admin"
  # Note: Don't commit real secrets to git! Use this for demos only.

# ===================
# USING IN DEPLOYMENT
# ===================
# Add to deployment.yaml containers section:
#
# Method 1: Load all as environment variables
# envFrom:
# - secretRef:
#     name: app-secrets
#
# Method 2: Load specific keys
# env:
# - name: DB_PASSWORD
#   valueFrom:
#     secretKeyRef:
#       name: app-secrets
#       key: DB_PASSWORD
#
# Method 3: Mount as files (for certificates, keys)
# volumeMounts:
# - name: secrets
#   mountPath: /etc/secrets
#   readOnly: true
# volumes:
# - name: secrets
#   secret:
#     secretName: app-secrets

# ===================
# CREATING SECRETS
# ===================
# From literal values:
#   kubectl create secret generic app-secrets \
#     --from-literal=DB_PASSWORD=mypassword \
#     --from-literal=API_KEY=myapikey
#
# From file:
#   kubectl create secret generic app-secrets \
#     --from-file=ssh-privatekey=/path/to/key
#
# TLS secret from cert files:
#   kubectl create secret tls tls-secret \
#     --cert=path/to/tls.cert \
#     --key=path/to/tls.key
#
# Apply this file:
#   kubectl apply -f k8s/advanced/secret.yaml

# ===================
# SECURITY BEST PRACTICES
# ===================
# 1. Never commit secrets to git
#    - Add secret.yaml to .gitignore
#    - Use this file as a template only
#
# 2. Use RBAC to restrict access
#    - Only allow specific service accounts to read secrets
#
# 3. Enable encryption at rest
#    - Configure Kubernetes to encrypt secrets in etcd
#
# 4. Use external secret managers (production)
#    - HashiCorp Vault
#    - AWS Secrets Manager
#    - Azure Key Vault
#    - GCP Secret Manager
#    - Sealed Secrets (encrypted in git)
#
# 5. Rotate secrets regularly
#    - Update and rollout deployment
#
# 6. Use least privilege
#    - Only mount secrets needed by each container

# ===================
# VIEWING SECRETS
# ===================
# List secrets:
#   kubectl get secrets -n go-demo
#
# Describe (doesn't show values):
#   kubectl describe secret app-secrets -n go-demo
#
# View values (use carefully!):
#   kubectl get secret app-secrets -n go-demo -o yaml
#
# Decode a specific value:
#   kubectl get secret app-secrets -n go-demo -o jsonpath='{.data.DB_PASSWORD}' | base64 -d

# ===================
# UPDATING SECRETS
# ===================
# Update the secret:
#   kubectl apply -f k8s/advanced/secret.yaml
#
# Restart pods to use new values:
#   kubectl rollout restart deployment/go-app -n go-demo
#
# Note: Pods don't automatically reload secrets!
# You need to restart or use a secret reloader controller.
